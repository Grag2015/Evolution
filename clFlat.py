#=======================================================================================================================
# класс - планировки квартир
#
#=======================================================================================================================
import copy

class clFlat:
    # атрибуты
    compartments=None
    sc=None # хранит текущую версию топологии (с учетом поворотов, обработки)
    sc_src = None # хранит исходную версию топологии
    pl=None
    H=None
    B=None
    nrot = 0 # количество поворотов по часовой стрелке
    diagrot0 = 0 # флаг диагональный поворот второстеп.диагональ
    diagrot1 = 0 # флаг диагональный поворот главная диагональ
    sc_preproc

    def __init__(self, compartments, sc):
        self.compartments = compartments
        self.sc = sc
        self.sc_src = copy.deepcopy(sc)

    # методы

    def rotate90(self, n):  # n time по часовой стрелке
        """
        >>> pl = [[0.0, 5.0, 0.0, 1.3636363636363635, 0.0, 3.1818181818181817, 1.3636363636363635, 2.2727272727272729,
        ... 2.2727272727272729, 3.1818181818181817, 0.0, 3.1818181818181817, 3.1818181818181817, 5.0],
        ... [0.0, 6.0, 0.0, 2.3999999999999999, 2.3999999999999999, 4.7999999999999998, 0.0, 2.3999999999999999, 0.0,
        ... 2.3999999999999999, 4.7999999999999998, 6.0, 0.0, 6.0]]
        >>> (rotate90(pl)[0][0],rotate90(pl)[0][5],rotate90(pl)[1][4],rotate90(pl)[1][6])
        (0.0, 3.0, 0.0, 1.6363636363636362)
        """
        if n == 0:
            return self
        if n == 1:
            pln = [[], []]
            pln[0] = map(lambda x: (x / float(H)) * B, pl[1])
            pln[1] = map(lambda y: (H - (y / float(B)) * H), pl[0])
            for i in range(len(pl[0]) / 2):
                b1 = min(pln[1][2 * i], pln[1][2 * i + 1])
                b2 = max(pln[1][2 * i], pln[1][2 * i + 1])
                pln[1][2 * i] = b1
                pln[1][2 * i + 1] = b2
            return pln
        else:
            return rotate90(rotate90(pl, n - 1), 1)